<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control System Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Include MathJax for LaTeX rendering -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        .card {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .plot-container {
            height: 300px; /* Fixed height for consistency */
            width: 100%;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 sm:p-8 font-sans">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-4xl font-bold text-gray-800 mb-6 text-center">Control System Analyzer</h1>

        <!-- Input and Control Panel -->
        <div class="card p-6 mb-8 rounded-xl">
            <h2 class="text-2xl font-semibold mb-4 text-gray-700">Define Transfer Function $G(s)$</h2>
            
            <p class="text-sm text-gray-500 mb-4 italic">Enter coefficients in descending order of powers of $s$. E.g., for $s^2 + 2s + 1$, enter `1, 2, 1`.</p>

            <!-- Prebuilt Selection -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="prebuilt" class="block text-sm font-medium text-gray-700 mb-1">Select Prebuilt Function:</label>
                    <select id="prebuilt" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm py-2 px-3 focus:ring-blue-500 focus:border-blue-500 transition duration-150 ease-in-out">
                        <option value="first_order_unit">Default: First Order Unit Gain (1/(s+1))</option>
                        <option value="custom">Custom Polynomial (G(s) = N(s)/D(s))</option>
                        <option value="integrator">Integrator (1/s)</option>
                        <option value="second_order_zeta">Second Order (Underdamped, $\zeta=0.5$)</option>
                        <option value="oscillating">Second Order (Undamped, $\zeta=0$)</option>
                        <option value="third_order">Higher Order (Third Order)</option>
                        <option value="lead_lag">Lead-Lag Filter</option>
                        <option value="fopdt">FOPDT Approximation</option>
                        <option value="sopdt">SOPDT Approximation</option>
                    </select>
                </div>
            </div>

            <!-- Display of the Transfer Function (G(s)) -->
            <div id="function-display" class="bg-gray-200 p-4 rounded-lg mb-6 text-center text-lg font-mono">
                <!-- Initial function will be set by the script -->
            </div>

            <!-- Custom Coefficient Input -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="numerator" class="block text-sm font-medium text-gray-700 mb-1">Numerator Coefficients (N(s)):</label>
                    <input type="text" id="numerator" value="1" placeholder="e.g., 1, 2, 1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500 transition duration-150 ease-in-out">
                </div>
                <div>
                    <label for="denominator" class="block text-sm font-medium text-gray-700 mb-1">Denominator Coefficients (D(s)):</label>
                    <input type="text" id="denominator" value="1, 1" placeholder="e.g., 1, 3, 2" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500 transition duration-150 ease-in-out">
                </div>
            </div>

            <div class="mt-6 flex justify-between items-center">
                <button id="plot-btn" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-300 ease-in-out">
                    Generate Plots
                </button>
                <div id="message" class="text-red-600 font-medium hidden"></div>
            </div>
        </div>

        <!-- Plots Section -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            
            <!-- Time Domain Plots -->
            <div class="card p-4 rounded-xl">
                <h3 class="text-xl font-medium text-gray-700 mb-4 text-center">Step Response (Time Domain)</h3>
                <div class="plot-container"><canvas id="stepResponseChart"></canvas></div>
                <p class="text-xs text-gray-500 mt-2 text-center">System response to a unit step input.</p>
            </div>
            
            <div class="card p-4 rounded-xl">
                <h3 class="text-xl font-medium text-gray-700 mb-4 text-center">Impulse Response (Time Domain)</h3>
                <div class="plot-container"><canvas id="impulseResponseChart"></canvas></div>
                <p class="text-xs text-gray-500 mt-2 text-center">System response to a unit impulse input (initial condition approximation used).</p>
            </div>
            
            <!-- Frequency Domain Plots (Bode) -->
            <div class="card p-4 rounded-xl">
                <h3 class="text-xl font-medium text-gray-700 mb-4 text-center">Bode Plot (Magnitude)</h3>
                <div class="plot-container"><canvas id="bodeMagChart"></canvas></div>
                <p class="text-xs text-gray-500 mt-2 text-center">Frequency response magnitude in dB.</p>
            </div>
            
            <div class="card p-4 rounded-xl">
                <h3 class="text-xl font-medium text-gray-700 mb-4 text-center">Bode Plot (Phase)</h3>
                <div class="plot-container"><canvas id="bodePhaseChart"></canvas></div>
                <p class="text-xs text-gray-500 mt-2 text-center">Frequency response phase in degrees.</p>
            </div>

            <!-- Nyquist Plot -->
            <div class="card p-4 rounded-xl lg:col-span-2">
                <h3 class="text-xl font-medium text-gray-700 mb-4 text-center">Nyquist Plot</h3>
                <div class="plot-container" style="height: 400px;"><canvas id="nyquistChart"></canvas></div>
                <p class="text-xs text-gray-500 mt-2 text-center">Polar plot of $G(j\omega)$ in the complex plane.</p>
            </div>

        </div>
    </div>

    <script>
        (function() {
            // --- Global Chart Instances ---
            let stepResponseChart, impulseResponseChart, bodeMagChart, bodePhaseChart, nyquistChart;

            // --- TRANSFER FUNCTION DEFINITIONS (FOR DISPLAY AND COEFFICIENT SETTING) ---
            const functions = {
                'custom': {
                    label: 'Custom Polynomial G(s)',
                    latex: 'G(s) = \\frac{N(s)}{D(s)}',
                    num: '1',
                    den: '1, 1'
                },
                'integrator': {
                    label: 'Integrator (1/s)',
                    latex: 'G(s) = \\frac{1}{s}',
                    num: '1',
                    den: '1, 0'
                },
                'first_order_unit': {
                    label: 'First Order Unit Gain (1/(s+1))',
                    latex: 'G(s) = \\frac{1}{s+1}',
                    num: '1',
                    den: '1, 1'
                },
                'second_order_zeta': {
                    label: 'Second Order (Underdamped, $\\zeta=0.5$)',
                    // FIX: Wrapped text in \text{} and used a space to prevent MathJax misinterpreting \quad
                    latex: 'G(s) = \\frac{1}{s^2 + s + 1} \\hspace{0.5em} \\text{(\\omega_n=1, \\zeta=0.5)}', 
                    num: '1',
                    den: '1, 1, 1'
                },
                'oscillating': {
                    label: 'Second Order (Undamped, $\\zeta=0$)',
                    // FIX: Wrapped text in \text{} and used a space to prevent MathJax misinterpreting \quad
                    latex: 'G(s) = \\frac{1}{s^2 + 1} \\hspace{0.5em} \\text{(\\omega_n=1, \\zeta=0)}', 
                    num: '1',
                    den: '1, 0, 1'
                },
                'third_order': {
                    label: 'Higher Order (Third Order)',
                    latex: 'G(s) = \\frac{1}{(s+1)^3} = \\frac{1}{s^3 + 3s^2 + 3s + 1}',
                    num: '1',
                    den: '1, 3, 3, 1'
                },
                'lead_lag': {
                    label: 'Lead-Lag Filter',
                    latex: 'G(s) = \\frac{0.1s+1}{0.01s+1} \quad (\\text{Lead Filter})',
                    num: '0.1, 1',
                    den: '0.01, 1'
                },
                'fopdt': {
                    label: 'FOPDT Approximation',
                    // FIX: Wrapped text in \text{} and used a space to prevent MathJax misinterpreting \quad
                    latex: 'G(s) \\approx \\frac{1 - s}{5s^2 + 6s + 1} \\hspace{0.5em} \\text{(T=5, \\theta=2, Pade 1st Order)}', 
                    num: '-1, 1', 
                    den: '5, 6, 1'
                },
                'sopdt': {
                    label: 'SOPDT Approximation',
                    // FIX: Wrapped text in \text{} and used a space to prevent MathJax misinterpreting \quad
                    latex: 'G(s) \\approx \\frac{1 - s/2}{(s+1)(s/2+1)} \\hspace{0.5em} \\text{(T=1, \\theta=1, Pade 1st Order)}', 
                    num: '-0.5, 1', 
                    den: '0.5, 1.5, 1'
                }
            };
            
            // --- Core Complex Number Implementation (Minimal) ---
            class Complex {
                constructor(re, im) {
                    this.re = re || 0;
                    this.im = im || 0;
                }

                // Complex addition: (a + bi) + (c + di) = (a+c) + (b+d)i
                add(other) { return new Complex(this.re + other.re, this.im + other.im); }

                // Complex multiplication: (a + bi)(c + di) = (ac - bd) + (ad + bc)i
                mult(other) {
                    return new Complex(
                        this.re * other.re - this.im * other.im,
                        this.re * other.im + this.im * other.re
                    );
                }

                // Complex division: (a + bi) / (c + di) = [(ac + bd) + (bc - ad)i] / (c^2 + d^2)
                div(other) {
                    const denominator = other.re * other.re + other.im * other.im;
                    if (denominator === 0) return new Complex(NaN, NaN); // Handle division by zero
                    return new Complex(
                        (this.re * other.re + this.im * other.im) / denominator,
                        (this.im * other.re - this.re * other.im) / denominator
                    );
                }

                mag() { return Math.sqrt(this.re * this.re + this.im * this.im); }

                phaseDeg() { return Math.atan2(this.im, this.re) * (180 / Math.PI); }
            }

            // Helper for j*omega
            const J = new Complex(0, 1);

            // --- Transfer Function Evaluation $G(j\omega)$ ---

            // Evaluates a polynomial P(s) = C[0]*s^n + C[1]*s^(n-1) + ... + C[n] at s=jw
            function polyval(coeffs, s) {
                let result = new Complex(0, 0);
                for (let i = 0; i < coeffs.length; i++) {
                    const power = coeffs.length - 1 - i;
                    const coeff = new Complex(coeffs[i], 0);

                    // Calculate s^power
                    let s_pow = new Complex(1, 0);
                    for (let p = 0; p < power; p++) {
                        s_pow = s_pow.mult(s);
                    }

                    result = result.add(coeff.mult(s_pow));
                }
                return result;
            }

            // Calculates G(j*omega)
            function calculateGjw(numCoeffs, denCoeffs, omega) {
                const jw = J.mult(new Complex(omega, 0));
                const N_jw = polyval(numCoeffs, jw);
                const D_jw = polyval(denCoeffs, jw);

                return N_jw.div(D_jw);
            }

            // --- State Space & Time Domain Solver (RK4) ---

            // Normalizes D(s) so leading coefficient is 1. Returns normalized [Num, Den]
            function normalizeCoeffs(num, den) {
                if (den.length === 0) return [num, den];
                
                const n = den[0];
                if (n === 0) {
                        // Denominator is 0. This is an invalid transfer function.
                        return [num, den];
                }
                
                const den_norm = den.map(c => c / n);
                const num_norm = num.map(c => c / n);
                
                // Pad numerator with leading zeros if necessary (m < n)
                const n_den = den_norm.length;
                const m_num = num_norm.length;
                
                const diff = n_den - m_num;
                const paddedNum = (diff > 0) ? [...Array(diff).fill(0), ...num_norm] : num_norm;

                return [paddedNum, den_norm];
            }

            // Time domain simulation using RK4 and Controllable Canonical Form (CCF)
            function timeResponseRK4(num, den, inputFn, finalTime, steps) {
                const [b, a] = normalizeCoeffs(num, den);
                const n = a.length - 1; // Order of the system

                if (n <= 0) {
                    // Handle constant gain or zero order system
                    const K = b[b.length - 1] / a[a.length - 1];
                    return [{ t: 0, y: K * inputFn(0) }, { t: finalTime, y: K * inputFn(finalTime) }];
                }
                
                const dt = finalTime / steps;
                const t_array = [];
                const y_array = [];
                let x = Array(n).fill(0); // State vector x (x1, x2, ..., xn)
                let t = 0;

                const derivative = (t_k, x_k) => {
                    const u = inputFn(t_k);
                    const x_dot = Array(n).fill(0);
                    
                    // x_dot[i] = x[i+1] for i = 0 to n-2
                    for (let i = 0; i < n - 1; i++) {
                        x_dot[i] = x_k[i + 1];
                    }

                    let a_dot_n_minus_1 = 0;
                    
                    // Sum the terms -a_i * x_{n-1-i}
                    for (let i = 1; i <= n; i++) {
                        const poly_coeff = a[i]; // i=1 -> a_{n-1}, i=n -> a_0
                        const state_index = n - i; // i=1 -> x_{n-1}, i=n -> x_0
                        a_dot_n_minus_1 -= poly_coeff * x_k[state_index];
                    }

                    // Add control input u
                    x_dot[n - 1] = a_dot_n_minus_1 + u;

                    return x_dot;
                };

                const calculateOutput = (x_k) => {
                    let y = 0;
                    for (let i = 1; i <= n; i++) {
                        const num_coeff = b[i]; 
                        const state_index = n - i; 
                        y += num_coeff * x_k[state_index];
                    }
                    return y;
                }

                // RK4 integration loop
                for (let i = 0; i <= steps; i++) {
                    t_array.push(t);
                    y_array.push(calculateOutput(x));

                    if (i === steps) break;

                    // k1 = dt * f(t, x)
                    const k1_dot = derivative(t, x);
                    const k1 = k1_dot.map(val => val * dt);

                    // k2 = dt * f(t + dt/2, x + k1/2)
                    const x_k1_mid = x.map((val, idx) => val + k1[idx] / 2);
                    const k2_dot = derivative(t + dt / 2, x_k1_mid);
                    const k2 = k2_dot.map(val => val * dt);

                    // k3 = dt * f(t + dt/2, x + k2/2)
                    const x_k2_mid = x.map((val, idx) => val + k2[idx] / 2);
                    const k3_dot = derivative(t + dt / 2, x_k2_mid);
                    const k3 = k3_dot.map(val => val * dt);

                    // k4 = dt * f(t + dt, x + k3)
                    const x_k3_end = x.map((val, idx) => val + k3[idx]);
                    const k4_dot = derivative(t + dt, x_k3_end);
                    const k4 = k4_dot.map(val => val * dt);

                    // x(t + dt) = x(t) + (k1 + 2*k2 + 2*k3 + k4) / 6
                    x = x.map((val, idx) => val + (k1[idx] + 2 * k2[idx] + 2 * k3[idx] + k4[idx]) / 6);
                    t += dt;
                }

                return t_array.map((t, i) => ({ t: t, y: y_array[i] }));
            }

            // --- Plotting Functions (Unchanged) ---

            // Destroy existing chart instances
            function destroyCharts() {
                [stepResponseChart, impulseResponseChart, bodeMagChart, bodePhaseChart, nyquistChart].forEach(chart => {
                    if (chart) chart.destroy();
                });
            }

            function createChart(ctx, type, title, data, options) {
                const defaultOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: false, text: title },
                        legend: { display: type === 'line' }
                    },
                    scales: {
                        x: {
                            type: options.scales.x.type || 'linear',
                            title: { display: true, text: options.scales.x.title || 'Time (s)' },
                            grid: { color: 'rgba(0,0,0,0.05)' }
                        },
                        y: {
                            title: { display: true, text: options.scales.y.title || 'Amplitude' },
                            grid: { color: 'rgba(0,0,0,0.05)' }
                        }
                    }
                };
                
                // Merge custom options
                const finalOptions = { ...defaultOptions, ...options };
                finalOptions.scales.x = { ...defaultOptions.scales.x, ...options.scales.x };
                finalOptions.scales.y = { ...defaultOptions.scales.y, ...options.scales.y };

                return new Chart(ctx, { type, data, options: finalOptions });
            }


            // --- Main Plotting Logic (Unchanged) ---

            function plotTransferFunction(numCoeffs, denCoeffs) {
                destroyCharts();
                const messageEl = document.getElementById('message');
                messageEl.classList.add('hidden');

                const num = numCoeffs.map(Number);
                const den = denCoeffs.map(Number);

                if (den.length === 0 || den.every(c => c === 0)) {
                    messageEl.textContent = 'Denominator cannot be zero.';
                    messageEl.classList.remove('hidden');
                    return;
                }
                if (num.length > den.length) {
                    messageEl.textContent = 'Transfer function must be proper (Order of N(s) <= Order of D(s)).';
                    messageEl.classList.remove('hidden');
                    return;
                }

                // --- 1. Time Domain Responses (Step and Impulse) ---
                const finalTime = 10;
                const steps = 500;
                
                // Step input: u(t) = 1 for t >= 0
                const stepData = timeResponseRK4(num, den, t => (t >= 0 ? 1 : 0), finalTime, steps);
                
                // Impulse input: Approximated by a short, high pulse (unit area)
                const impulseData = [];
                for(let i = 1; i < stepData.length; i++) {
                    const dt = stepData[i].t - stepData[i-1].t;
                    const dy_dt = (stepData[i].y - stepData[i-1].y) / dt;
                    impulseData.push({t: stepData[i].t, y: dy_dt});
                }

                // Step Response Plot
                stepResponseChart = createChart(document.getElementById('stepResponseChart').getContext('2d'), 'line', 'Step Response', {
                    datasets: [{
                        label: 'y(t)', data: stepData.map(d => ({ x: d.t, y: d.y })), borderColor: 'rgb(59, 130, 246)', 
                        tension: 0.1, borderWidth: 2, pointRadius: 0, fill: false
                    }]
                }, { 
                    scales: { x: { type: 'linear', title: 'Time (s)' }, y: { title: 'Output y(t)' } } 
                });

                // Impulse Response Plot
                impulseResponseChart = createChart(document.getElementById('impulseResponseChart').getContext('2d'), 'line', 'Impulse Response', {
                    datasets: [{
                        label: 'h(t)', data: impulseData.map(d => ({ x: d.t, y: d.y })), borderColor: 'rgb(16, 185, 129)', 
                        tension: 0.1, borderWidth: 2, pointRadius: 0, fill: false
                    }]
                }, { 
                    scales: { x: { type: 'linear', title: 'Time (s)' }, y: { title: 'Output h(t)' } } 
                });


                // --- 2. Frequency Domain Responses (Bode and Nyquist) ---
                const w_start = 0.01; // rad/s
                const w_end = 100;    // rad/s
                const numPoints = 200;
                const frequencies = [];
                for (let i = 0; i < numPoints; i++) {
                    // Logarithmic spacing
                    const log_w = Math.log10(w_start) + (Math.log10(w_end) - Math.log10(w_start)) * (i / numPoints);
                    frequencies.push(Math.pow(10, log_w));
                }

                const bodeMagData = [];
                const bodePhaseData = [];
                const nyquistData = [];

                frequencies.forEach(w => {
                    const Gjw = calculateGjw(num, den, w);
                    
                    // Bode Data
                    const mag_db = 20 * Math.log10(Gjw.mag());
                    const phase_deg = Gjw.phaseDeg();

                    bodeMagData.push({ x: w, y: mag_db });
                    bodePhaseData.push({ x: w, y: phase_deg });

                    // Nyquist Data
                    nyquistData.push({ x: Gjw.re, y: Gjw.im });
                });
                
                // Bode Magnitude Plot
                bodeMagChart = createChart(document.getElementById('bodeMagChart').getContext('2d'), 'line', 'Bode Magnitude', {
                    datasets: [{
                        label: '|G(jω)| (dB)', data: bodeMagData, borderColor: 'rgb(245, 158, 11)', 
                        tension: 0, borderWidth: 2, pointRadius: 0, fill: false
                    }]
                }, {
                    scales: {
                        x: { type: 'logarithmic', title: 'Frequency ω (rad/s)' },
                        y: { title: 'Magnitude (dB)' }
                    }
                });

                // Bode Phase Plot
                bodePhaseChart = createChart(document.getElementById('bodePhaseChart').getContext('2d'), 'line', 'Bode Phase', {
                    datasets: [{
                        label: '∠G(jω) (deg)', data: bodePhaseData, borderColor: 'rgb(239, 68, 68)', 
                        tension: 0, borderWidth: 2, pointRadius: 0, fill: false
                    }]
                }, {
                    scales: {
                        x: { type: 'logarithmic', title: 'Frequency ω (rad/s)' },
                        y: { title: 'Phase (degrees)' }
                    }
                });

                // Nyquist Plot (Real vs. Imaginary)
                nyquistChart = createChart(document.getElementById('nyquistChart').getContext('2d'), 'line', 'Nyquist Plot', {
                    datasets: [
                        {
                            label: 'G(jω)', data: nyquistData, borderColor: 'rgb(124, 58, 237)', 
                            tension: 0, borderWidth: 2, pointRadius: 2, showLine: true
                        },
                        { // Origin marker
                            label: '', data: [{ x: 0, y: 0 }], backgroundColor: 'black', type: 'scatter', pointRadius: 5
                        },
                        { // (-1, 0) marker for stability
                            label: '(-1, 0)', data: [{ x: -1, y: 0 }], backgroundColor: 'red', type: 'scatter', pointRadius: 5, fill: false
                        }
                    ]
                }, {
                    plugins: { legend: { display: true } },
                    scales: {
                        x: { type: 'linear', title: 'Real Axis' },
                        y: { title: 'Imaginary Axis', beginAtZero: false }
                    }
                });
            }

            // --- Event Handlers and Initialization ---

            function setFunctionDisplay(latex) {
                const display = document.getElementById('function-display');
                // Use MathJax to render the LaTeX string
                display.innerHTML = `$$${latex}$$`; 
                // Instruct MathJax to typeset the content
                if (window.MathJax) {
                    MathJax.typeset([display]);
                }
            }

            function handlePrebuiltChange() {
                const prebuiltKey = document.getElementById('prebuilt').value;
                const numeratorInput = document.getElementById('numerator');
                const denominatorInput = document.getElementById('denominator');

                const func = functions[prebuiltKey];

                if (func) {
                    numeratorInput.value = func.num;
                    denominatorInput.value = func.den;
                    setFunctionDisplay(func.latex);
                } else {
                    // This handles 'custom' or unknown keys, reverting to default display
                    setFunctionDisplay(functions['custom'].latex);
                }
            }

            function handlePlotClick() {
                const numStr = document.getElementById('numerator').value.trim();
                const denStr = document.getElementById('denominator').value.trim();

                const numCoeffs = numStr.split(',').map(c => parseFloat(c.trim())).filter(c => !isNaN(c));
                const denCoeffs = denStr.split(',').map(c => parseFloat(c.trim())).filter(c => !isNaN(c));
                
                // Validate the first term of the denominator
                if (denCoeffs.length > 0 && denCoeffs[0] === 0) {
                        document.getElementById('message').textContent = 'The highest order coefficient in the denominator cannot be zero.';
                        document.getElementById('message').classList.remove('hidden');
                        return;
                }

                if (numCoeffs.length === 0 || denCoeffs.length === 0) {
                    document.getElementById('message').textContent = 'Please enter valid, non-empty lists of coefficients.';
                    document.getElementById('message').classList.remove('hidden');
                    return;
                }

                // If plotting a custom function, update the display to show the current coefficients
                if (document.getElementById('prebuilt').value === 'custom') {
                    const numPoly = numCoeffs.map((c, i) => {
                        const power = numCoeffs.length - 1 - i;
                        if (c === 0) return '';
                        const sTerm = power > 1 ? `s^{${power}}` : (power === 1 ? 's' : '');
                        const sign = c > 0 && i > 0 ? '+' : '';
                        const coeff = Math.abs(c) === 1 && power > 0 ? (c < 0 ? '-' : '') : c;
                        return `${sign}${coeff}${sTerm}`;
                    }).join('').replace(/^\+/, ''); 
                    
                    const denPoly = denCoeffs.map((c, i) => {
                        const power = denCoeffs.length - 1 - i;
                        if (c === 0) return '';
                        const sTerm = power > 1 ? `s^{${power}}` : (power === 1 ? 's' : '');
                        const sign = c > 0 && i > 0 ? '+' : '';
                        const coeff = Math.abs(c) === 1 && power > 0 ? (c < 0 ? '-' : '') : c;
                        return `${sign}${coeff}${sTerm}`;
                    }).join('').replace(/^\+/, '');

                    setFunctionDisplay(`G(s) = \\frac{${numPoly || '0'}}{${denPoly || '1'}}`);
                }

                plotTransferFunction(numCoeffs, denCoeffs);
            }

            document.addEventListener('DOMContentLoaded', () => {
                // Initialize MathJax library (included in the <head>)
                if (window.MathJax) {
                    MathJax.startup.defaultReady();
                }

                document.getElementById('prebuilt').addEventListener('change', handlePrebuiltChange);
                document.getElementById('plot-btn').addEventListener('click', handlePlotClick);

                // Set initial values and display the function
                document.getElementById('prebuilt').value = 'first_order_unit';
                handlePrebuiltChange(); 
                handlePlotClick(); 
            });
        })();

    </script>
</body>
</html>